
use importer;
use station_index;
use station;
use river;
use river_index;

use runtime;
use io;


type WaterImporterService {
  static fn importStations() {
    var data = WaterImporter::getStations();

    //Init the station index
    stations_by_id ?= nodeIndex<int, node<Station>>::new();

    //Init the river index
    rivers_by_id ?= nodeIndex<int, node<River>>::new();

    for (idx, obj in data) {
      var stationId = obj.get("id") as int;
      //Check if the station already exists
      var nStation = stations_by_id.get(stationId);

      if (nStation == null) {
        //Create a new station
        var station = Station::createFromMap(obj);
        nStation = node<Station>::new(station);
        stations_by_id.set(station.id, nStation);
      }

      //Update the river -> station relationship
      var river = nStation->river!!;

      var riverStation = river->stations.get(stationId);
      if (riverStation == null) {
        river->stations.set(stationId, nStation!!);
      }

      //Add the river to the river index
      if (rivers_by_id.get(river->id) == null) {
        rivers_by_id.set(river->id, river);
      }
    }
  }

  static fn importWaterLevelsByStation(nStation: node<Station>) {
    //measuremnts ealiest time
    var earliestTime = time::new(1518210521, DurationUnit::seconds);

    var stationId = nStation->id;

    info("Fetching Water Level For Station: ${stationId}");
    try {
      var firstTime = nStation->waterLevels.firstTime() ?? time::now();
      var lastTime = nStation->waterLevels.lastTime() ?? time::now();

      var from: time?;
      var to: time?;

      //Fetch data as long as we have not reached the earliest time
      if (firstTime > earliestTime) {
        from = firstTime - 30_day;
        to = firstTime;
      } else if ((time::now() - lastTime) > 1_day) {
        //Fetch data for the last day
        from = lastTime;
        to = time::now();
      }

      if (from != null && to != null) {
        info("Fetching Water Level For Station: ${stationId} From: ${from.toDateUTC().toString()} To: ${to.toDateUTC().toString()}");
        var data = WaterImporter::getStationWaterLevels(stationId, from, to);

        if (data.size() == 0) {
          info("Request returned empty data: ${stationId}");
        } else {
          nStation->addWaterLevel(data);
        }
      } else {
        info("No more data to fetch for station: ${stationId}");
      }
    } catch (err) {
      info("Error Fetching Water Level For Station: ${stationId}");
      info(err);
    }
  }

  // static fn storeToCsv(stationId: int, data: Array<Map<String, any>>) {
  //   var format = CsvFormat {};
  //   var fw = CsvWriter::new_append("station_${stationId}.csv", format);

  //   for (key, value in data) {
  //     //data format "2017-12-27T07:15:00"
  //     var date = value.get("timestamp") as String;
  //     var level = value.get("value") as float?;
  //     var t = time::parse(date);

  //     fw.write([t.to(DurationUnit::seconds), level]);
  //   }
  // }
}